<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Robotics-Linear Control]]></title>
    <url>%2F2018%2F12%2F27%2FRobotics-Linear%20Control%2F</url>
    <content type="text"><![CDATA[1 IntroductionPremise: Know the means to calculate joint-position correspond to desired end-effector motions. Problem: Howto casuse the manipulator acually to perform these desired motions. Solution 1: Linear control system. In fact, non-linear is more usual, linear control is just a approximate methods It’s resonable to make such approximation, so lineat control methods are the ones most often used in industrial practice. Learn linear first is good for later study 2 Control-Law PartitioningPartitioning Method (2 parts): model-based portion: make use of supposed knowledge of m,b,k, to make the system appear as a unit mass$\to$ servo portion simple. servo portion: make use of feedback to modify the behavior of the system A open-loop equation of motion for the system:$$m \ddot { x } + b \dot { x } + k x = f$$The model-based portion of the control:$$f = \alpha f ^ { \prime } + \beta$$and we choose(because we want to make the )$$\begin{array} { l } { \alpha = m } \ { \beta = b \dot { x } + k x } \end{array}$$finally we get $\ddot { x } = f ^ { \prime }$ Graphiclly,we transform a system like this into a system easier What we need to do is design a control law to compute $f ^ { \prime } = - k _ { v } \dot { x } - k _ { p } x$ so it yields$$\ddot { x } + k _ { v } \dot { x } + k _ { p } x = 0$$ Conclusion get the system‘s parameters find $\alpha ,\beta$ calculate $k_v,k_p$ depend on the requirement 3. Trajectory-Following ControlKnow: trajectory, a funciton of time $x_d(t)$ and we can get $\dot x_d, \ddot x_d $as well Define: $e=x_d-x$ Design $f ^ { \prime } = \ddot { x } _ { d } + k _ { v } \dot { e } + k _ { p } e$ Get: $\ddot { x } = \ddot { x } _ { d } + k _ { v } \dot { e } + k _ { p } e$ So, we can choose coefficients and design any response we want]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Evaluate Hypothesis]]></title>
    <url>%2F2018%2F12%2F27%2FEvaluatehypothesis%2F</url>
    <content type="text"><![CDATA[Motivationhow to evaluate the accuracy of the algorithm Key Problem： test data should not be relative to the hypothesis、]]></content>
      <categories>
        <category>CS</category>
        <category>ML</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32-ADC]]></title>
    <url>%2F2018%2F12%2F27%2FSTM32-ADC%2F</url>
    <content type="text"><![CDATA[1 IntroductionSTM32 have one of the most advanced ADCs on microcontroller market. This note provide users to understand some modes offered in STM32 2 Independent Mode Single Channel, single conversion Example: Check if the battery voltage is succulent or not Multichannel, single conversion Example: Can be used when starting system depends on some parameters Single Channel, continuous conversion Example: Run in background, so can be used as a monitor to check something all the time Injected conversion Intended for use when conversion is triggered by an external event or by software. 3 Example Code1234567891011121314151617181920212223242526272829303132333435363738394041void GPIOINIT_ADC()&#123; GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;//ADC GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN; //模拟输入 GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOB,&amp;GPIO_InitStructure);&#125;void RCCINIT_ADC()&#123; SystemInit(); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE); RCC_ADCCLKConfig(RCC_PCLK2_Div6);//12M 最大14M 设置ADC时钟（ADCCLK）&#125;void ADCINIT_ADC()&#123; ADC_InitTypeDef ADC_InitStructure; ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; ADC_InitStructure.ADC_ScanConvMode = DISABLE; ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStructure.ADC_NbrOfChannel = 1; ADC_Init(ADC1, &amp;ADC_InitStructure); ADC_TempSensorVrefintCmd(ENABLE); ADC_Cmd(ADC1,ENABLE); ADC_ResetCalibration(ADC1);//重置指定的ADC的校准寄存器 while(ADC_GetResetCalibrationStatus(ADC1));//获取ADC重置校准寄存器的状态 ADC_StartCalibration(ADC1);//开始指定ADC的校准状态 while(ADC_GetCalibrationStatus(ADC1));//获取指定ADC的校准程序 ADC_RegularChannelConfig(ADC1,ADC_Channel_8,1,ADC_SampleTime_239Cycles5);//设置指定ADC的规则组通道，设置它们的转化顺序和采样时间 ADC_SoftwareStartConvCmd(ADC1, ENABLE);//使能或者失能指定的ADC的软件转换启动功能 while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);&#125;]]></content>
      <categories>
        <category>Embedded System</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>ADC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robotics-Linear Control]]></title>
    <url>%2F2018%2F12%2F27%2FRobotics-Force%20Control%2F</url>
    <content type="text"></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robotics-Trajectory]]></title>
    <url>%2F2018%2F12%2F25%2FRobotics-Trajectory%2F</url>
    <content type="text"><![CDATA[1 Introduction trajectory refers to a time history of position, velocity, and acceleration for each degree of freedom. Concern: Easy description：just desired goal position and orientation How to generating and representing in computer 2 General consideration Huamn-interface. Consider tool frame ${T}$ , in which a user would think and design path. Path include many intermediate points (position and orientation) Want a smooth path, first derivative even second derivative. jerky motions tend to cause increased wear on the mechanism andcause vibrations by exciting resonances in the manipulator 3 Joint-Space SchemesFirst get the via points and then convert it to a set of joint angle by inverse kinematics Joint space schemes is the easiest to compute. 3.1 Cubic PolynomialsSome constrains: $θ(0) = θ_0$ initial $θ(t_f ) = θ_f$ final $\dotθ(0) = 0$ continuous in velocity $\dotθ(t_f ) = 0$ continuous in velocity apply$$θ(t) = a_0 + a_1t + a_2t^2 + a_3t^3solve the problem$$to solve the problem (between two points) 3.2 Cubic polynomials for a path with via pointsWhat if we wish to specfify the intermediate via points? (between many points) constrains becoms $θ(0) = θ_0$ initial $θ(t_f ) = θ_f$ final $\dotθ(0) = \dot\theta_0$ continuous in velocity $\dotθ(t_f ) = \dot\theta_f$ continuous in velocity But how we choose the intermediate velocity? There are some method: Specified by user Choose by computer If the slope of lines change sign at via point $\to$zero velocity if the slope of lines does not change sign$\to$average velocity 3.3 Linear function with parabolic blends $$\ddotθ\times t_b =\frac{θ_h − θ_b}{t_h − t_b}$$ $$θ_b = θ_0 + \frac12\ddotθ\times t_b^2$$ There are 2 equations and 6 variabels So, given $\theta_f ,\theta_0, t_h$, choose $\ddot\theta\to$we can calculate $t_b$ 3.4 Linear function with parabolic blends for a path with via pointsConsider there an arbitrary number of via points 4 Cartesian-Space Schemes In Joint-Space, the spatial shape of path taken by the end-effector will be complicated In Cartesian-Space, we can also specify shape of the path. Line\Circular\Sinusoidal However, Cartesian schemes are more computationally expensive because inverse kinematics must be solved at real time 5 Geometric Problems with Cartesian Paths Intermediate points unreachable High joint rates near singularity Start and goal reachable in different solutions]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>trajectory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADS-Analysis]]></title>
    <url>%2F2018%2F12%2F24%2FADS-Analysis%2F</url>
    <content type="text"><![CDATA[1. Big Picture What makes a program better？many valid criteria, which are often in conflict. omputer scientists love Time Memory trade off sum of 1-n： simple add gauss formula 2. Big O Notation f(n) Name 1 Constant $log n$ Logarithmic $n$ Linear $nlogn$ Log Linear $n^2$ Quadratic $n^3$ Cubic $2^n$ Exponential 3. Example :Anagram Detection Checking off: check one by one ,$O(n^2)$. Sort and Compare: $O(nlogn)$ Brute Force , try all possibilities: $O(n!)$ Count and Compare: $O(n)$ 4. Performance of Python Types Lists Indexing &amp; Assigning &amp; Appending $O(1)$ Poping, Shifting &amp; Deleting, normally $O(n)$ ,beacuse has to shift changed element Reversing $O(n)$ Dictionaries “getting” and “setting” : $O(1)$ Iterating &amp; Copying: $O(n)$]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADS-Stacks]]></title>
    <url>%2F2018%2F12%2F24%2FADS-Stacks%2F</url>
    <content type="text"><![CDATA[1. Introduction to StacksStacks is a kind of linear data structures. What distinguishes one linear structure from another is where additions and removals may occur 1.1 Stacks A stack is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end. Example: stack of books\plates, URL back button Usage: reverse the order 1.2 ADT ADT data represents DS physical implementation of an ADT Stack operation Stack contents Return value s.is_empty() [] True s.push(4) [4] s.push(‘dog’) [4, ‘dog’] s.peek() [4, ‘dog’] ‘dog’ s.push(True) [4, ‘dog’, True] s.size() [4, ‘dog’, True] 3 s.is_empty() [4, ‘dog’, True] False s.push(8.4) [4, ‘dog’, True, 8.4] s.pop() [4, ‘dog’, True] 8.4 s.pop() [4, ‘dog’] True s.size() [4, ‘dog’] 2 2. A Stack ImplementationIn practice , “use a Python list as a stack” even though the implementations are logically equivalent, they would have very different timings when performing benchmark testing. Here, just use python list with limit function. 3. Example:Balanced Parenthesesparentheses are used to order the performance of operations $$(5+6)×(7+8)/(4+3)$$ or lisp function 12(defun square(n) (* n n)) So,it’s important to differentiate between parentheses that are correctly balanced and those that are unbalanced in strucures. Why Stack ? open match close\ close match open, reverse order So a stack, push if open, pop if close. Finally, if len(stack)==0, balance. 123456789101112131415161718192021222324252627PAIRINGS = &#123; '(': ')', '&#123;': '&#125;', '[': ']'&#125;def is_balanced(symbols): stack = [] for s in symbols: if s in PAIRINGS.keys(): stack.append(s) continue try: expected_opening_symbol = stack.pop() except IndexError: # too many closing symbols return False if s != PAIRINGS[expected_opening_symbol]: # mismatch return False return len(stack) == 0 # false if too many opening symbolsis_balanced('&#123;&#123;([][])&#125;()&#125;') # =&gt; Trueis_balanced('&#123;[])') # =&gt; Falseis_balanced('((()))') # =&gt; Trueis_balanced('(()') # =&gt; Falseis_balanced('())') # =&gt; False 4. Example: Converting Number Bases$$233_{10}=11101001_{2}$$ Why stack？ Divide by Base algorithm So, Push fisrt, Pop at the end 1234567891011121314151617181920DIGITS = '0123456789abcdef'def convert_to_base(decimal_number, base): remainder_stack = [] while decimal_number &gt; 0: remainder = decimal_number % base remainder_stack.append(remainder) decimal_number = decimal_number // base new_digits = [] while remainder_stack: new_digits.append(DIGITS[remainder_stack.pop()]) return ''.join(new_digits)convert_to_base(25, 2) # =&gt; '11001'convert_to_base(25, 16) # =&gt; '19' 5. Example: Infix, Prefix and Postfix Expressions Infix expression Prefix expression Postfix expression A + B + A B A B + A + B * C + A * B C A B C * + Infix expression need parenthese to force the performance of addition before multiplication. Prefix &amp; Postfixexpression DON’T need it How to convert infix to prefix or postfix? Fully parenthesize the expression using the order of operations. Then move the enclosed operator to the position of either the left or the right parenthesis depending on whether you want prefix or postfix notation. 5.1 Algorithm Create an empty stack called operation_stack for keeping operators. Create an empty list for output. Convert the input infix string to a list by using the string method split. Scan the token list from left to right. If the token is an operand, append it to the end of the output list. If the token is a left parenthesis, push it on the operation_stack. If the token is a right parenthesis, pop the operation_stack until the corresponding left parenthesis is removed. Append each operator to the end of the output list. If the token is an operator, *, /, +, or -, push it on the operation_stack. However, first remove any operators already on the operation_stack that have higher or equal precedence and append them to the output list. When the input expression has been completely processed, check the operation_stack. Any operators still on the stack can be removed and appended to the end of the output list. 5.2 Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445PRECEDENCE = &#123; '*': 3, '/': 3, '+': 2, '-': 2, '(': 1&#125;CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'DIGITS = '0123456789'LEFT_PAREN = '('RIGHT_PAREN = ')'def infix_to_postfix(infix_expression): operation_stack = [] postfix = [] tokens = infix_expression.split() for token in tokens: if token in CHARACTERS or token in DIGITS: postfix.append(token) elif token == LEFT_PAREN: operation_stack.append(token) elif token == RIGHT_PAREN: top_token = operation_stack.pop() while top_token != LEFT_PAREN: postfix.append(top_token) top_token = operation_stack.pop() else: while operation_stack and \ (PRECEDENCE[operation_stack[-1]] &gt;= PRECEDENCE[token]): postfix.append(operation_stack.pop()) operation_stack.append(token) while operation_stack: postfix.append(operation_stack.pop()) return ' '.join(postfix)infix_to_postfix('A * B + C * D') # =&gt; 'A B * C D * +'infix_to_postfix('( A + B ) * C - ( D - E ) * ( F + G )')# =&gt; 'A B + C * D E - F G + * -'infix_to_postfix('( A + B ) * ( C + D )') # =&gt; 'A B + C D + *'infix_to_postfix('( A + B ) * C') # =&gt; 'A B + C *'infix_to_postfix('A + B * C') # =&gt; 'A B C * +']]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
