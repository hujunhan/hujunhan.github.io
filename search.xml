<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TODO]]></title>
    <url>%2F2020%2F01%2F03%2FTODO%2F</url>
    <content type="text"><![CDATA[复习过控实验——6日 机器学习论文——13日 毛概展示PPT及论文整合——6日 机器人学大作业(代码、报告)——15日 传感检测复习——20号 嵌入式复习——16号 过控复习——22日 机器人学复习——19日 毛概复习——19日 机器视觉与机器学习复习——17日]]></content>
      <categories>
        <category>TODO</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Robotics-Final Project]]></title>
    <url>%2F2019%2F01%2F03%2Frobotics-final-project%2F</url>
    <content type="text"><![CDATA[1 问题分析1.1 题目要求 要求：如图所示操作臂，请规划机械臂各关节的轨迹，使其末端定点转动，即机械臂末端位置不变，姿态变化，并利用matlab robotics toolbox 进行验证和演示。 1.2 任务分解可以将以上任务分解为多个小任务 对机械臂进行坐标系建立 选取合适的Denavit-Hartenberg参数 正运动学分析 逆运动学分析 轨迹规划 利用robotics toolbox仿真演示 1.3 基本思路首先求取Denavit-Hartenberg参数，然后利用正运动学求出末端端点的位姿表达式（ SE3 ），然后对末端端点施加微小旋转作用，得到新的位姿表达式，然后利用逆运动学求解出此时机械臂所应该具有的joint angle，然后利用robotics toolbox的plot函数仿真表示出实际效果 2 各部分任务求解2.1 机械臂的坐标系建立 2.2 D-H参数选取 D-H参数表 $a_{i-1}$ $\alpha_{i-1} $ $d_i$ $\theta_i$ $1$ $0$ $0$ $2$ $q_1$ $2$ $2$ $\frac{\pi}{2}$ $0$ $q_2$ $3$ $\frac{\pi}{2}$ $\frac{\pi}{2} $ $d_3$ $0$ $4$ $0$ $\frac{\pi}{2} $ $0.5$ $q_3$ 2.3 正运动学分析因为机械臂的最后还有一个tool，不作为关节，但是最后是要以它作为末端端点，因此除了普通的正向运动学计算，最后还要加上一个tool的坐标系，在上图我的坐标系建立中可以看到只需要在最后一个坐标系${x_4,y_4,z_4}$的$y_4$上增加一个偏移就可以实现。 代码实现 1234567%Single transformfunction Trans=Transform(a,alpha,d,theta) Trans=[[cos(theta),-sin(theta),0,a]; [sin(theta)*ca,cos(theta)*ca,-sa,-sa*d]; [sin(theta)*sa,cos(theta)*sa,ca,ca*d]; [0,0,0,1]];end 12345678%Overall transformsyms q1 q2 d3 q4;T10=Transform(0,0,2,q1); T21=Transform(2,pi/2,0,q2); T32=Transform(0,pi/2,d3,0); T43=Transform(0,pi/2,0.5,q4); tool=[1 0 0 0;0 1 0 2; 0 0 1 0; 0 0 0 1]; T=T10*T21*T32*T43*tool; 数学表达 Single transform Overall transform 2.4 逆运动学分析2.4.1 初始位置2.4.2 位姿旋转2.4.3 解析求解3 仿真及结果分析3.1 机械臂模型建立首先根据之前的D-H参数，利用robotics toolbox进行建模，为了让模型更加适用于模块，所以除了4个确定的关节，在增加两个固定的“关节”，使机械臂成为6-DOF机械臂 代码如下： 12345678910111213L0=Revolute('qlim',[0,0],'modified')L1=Revolute('d',2,'modified');L2=Revolute('a',2,'alpha',1.5708,'modified');L3=Prismatic('theta',pi/2,'alpha',1.5708,'qlim',[0.2,5],'modified');L4=Revolute('alpha',pi/2,'d',0.5,'modified');L5 = Prismatic('alpha',-pi/2 ,'qlim',[2,2],'modified');L=[L0,L1,L2,L3,L4,L5];arm=SerialLink(L);arm.name='ZJU Robotics Final Arm';arm.manufacturer='CSE Hu';%设定初始值qz=[0,0,pi/3,4,-pi/6,2];arm.plot(qz) 效果如下： 3.2 正向运动学计算 通过robotics toolbox函数fkine(qz)计算得到的末端位姿为$$\begin{equation} %开始数学环境\left( %左括号 \begin{array}{cccc} %该矩阵一共3列，每一列都居中放置 -0.4330 &amp; -0.5000&amp; 0.7500 &amp; 7.964\\ -0.8660 &amp; 0.0000 &amp; -0.5000 &amp; -1\ 0.2500 &amp;-0.8660 &amp; -0.4330 &amp; 0.866\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{array}\right) %右括号\end{equation}$$ 通过自己编写函数计算得到的末端位姿为$$\begin{equation} %开始数学环境\left( %左括号 \begin{array}{cccc} %该矩阵一共3列，每一列都居中放置 -0.4330 &amp; -0.5000&amp; 0.7500 &amp; 7.9641\\ -0.8660 &amp; 0.0000 &amp; -0.5000 &amp; -1\ 0.2500 &amp;-0.8660 &amp; -0.4330 &amp; 0.866\\ 0 &amp; 0 &amp; 0 &amp; 1 \end{array}\right) %右括号\end{equation}$$ 对比可以发现是一样的。因此仿真确实可以达到实际的效果。]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADS-Queues]]></title>
    <url>%2F2019%2F01%2F03%2FADS-Queues%2F</url>
    <content type="text"><![CDATA[1 Introduction1.1 Queues A queue is an ordered collection of items where the addition of new items happens at one end, called the “rear,” and the removal of existing items occurs at the other end, commonly called the “front.” Example: wait in a line for a movie/ OS use queues control processes Usage: keep in order 1.2 ADT Queue Operation Queue Contents Return Value q.is_empty() [] True q.enqueue(4) [4] q.enqueue(‘dog’) [‘dog’, 4] q.enqueue(True) [True, ‘dog’, 4] q.size() [True, ‘dog’, 4] 3 q.is_empty() [True, ‘dog’, 4] False q.enqueue(8.4) [8.4, True, ‘dog’, 4] q.dequeue() [8.4, True, ‘dog’] 4 q.dequeue() [8.4, True] ‘dog’ q.size() [8.4, True] 2 2 A Queue ImplementationIn practice, use the standard library’s collections.deque to achieve high performance( $O(1)$) enqueues and dequeues.]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robotics-Force Control]]></title>
    <url>%2F2019%2F01%2F01%2FRobotics-Force%2F</url>
    <content type="text"><![CDATA[1 IntroductionMere position control is not suffice is contact is made between end-effector and environment. So introduce hybrid position/force controller to solve the problem. This method is one formalism through which industrial robots might someday be controlled in order to perform tasks requiring force control. 2 Application of Robots to Assembly Tasks Spot welding Spray painting Pick and place operations Future: assembly-line tasks, force is extremely important. Currently, the dexterity of manipulators remains quite low and limit their appplication in the automated assembly area. If we can measure and control contact forces generated at the hand, we can imporove the performance without using bigger, heavier, and more expensive manipulator. Basic IdeaEvery manipulation task can be broken down into subtasks that are defined by a particular contact situation occurring between the manipulator end-effector (or tool) and the work environment. With each subtask, we can associate a set of constrains mechanical geometric]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robotics-Nonlinear Control]]></title>
    <url>%2F2019%2F01%2F01%2FRobotics-Nonlinear%2F</url>
    <content type="text"><![CDATA[1 IntroductionIn linear control, we modeled the manipulator by $n$ independent second-order differential equations. In this chapter, we will base our controller design on the $n \times 1$ vector differential equation 2 Nonlinear local linearization When nonlinearities are not severe, local linearization can be used in the neighborhood of an operating point. But, manipulator move among regions so widely separated that no linearization valid for all regions can be found. moving linearization move the operating point with the manipulator as itmoves, always linearizing about the desired position of the manipulator deal with the nonlinear directly the poles of the system will “move”, so we can not select fixed gains. Instead, the gains are also time-varying so it will keep the system critically damped Example: nonlinear spring open loop equation: $m \ddot { x } + b \dot { x } + q x ^ { 3 } = f$ servo portion: $f ^ { \prime } = \ddot { x } _ { d } + k _ { v } \dot { e } + k _ { p } e$ model-based portion: changed ​ $\begin{array} { l } { \alpha = m } \ { \beta = b \dot { x } + q x ^ { 3 } } \end{array}$ ##3 Control problem for Manipulators For manipulator, the model is complicated$$\tau = M ( \Theta ) \ddot { \Theta } + V ( \Theta , \dot { \Theta } ) + G ( \Theta )$$where $\Theta $ is the position of all the joints. If we add friction to the model, we get$$\tau = M ( \Theta ) \ddot { \Theta } + V ( \Theta , \dot { \Theta } ) + G ( \Theta ) + F ( \Theta , \dot { \Theta } )$$where we can use our partitioned controller again:$$\tau = \alpha \tau ^ { \prime } + \beta$$and we choose$$\begin{aligned} \alpha &amp; = M ( \Theta ) \ \beta &amp; = V ( \Theta , \dot { \Theta } ) + G ( \Theta ) + F ( \Theta , \dot { \Theta } ) \end{aligned}$$servo law: $\tau ^ { \prime } = \ddot { \Theta } _ { d } + K _ { v } \dot { E } + K _ { p } E$ where $E = \Theta _ { d } - \Theta$ finally we get$$\ddot { E } + K _ { v } \dot { E } + K _ { p } E = 0$$This solve the problem in theory, but not in practice because computer do it by discrete nature inaccuracy in manipulator model 4 Current industrial-robot Control SystemParameters may be inaccurate. So model-based control law maybe doesn’t make sense For economic reasons, error driven is more usual. individual-joint PID control average gain are chosen $\tau ^ { \prime } = \ddot { \Theta } _ { d } + K _ { v } \dot { E } + K _ { p } E + K _ { i } \int Edt$ 5 Lyapunov Stability AnalysisA analytically way to evluate stability but not the performance.]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notes about Dropout]]></title>
    <url>%2F2018%2F12%2F30%2FDropout%2F</url>
    <content type="text"><![CDATA[Abstract深度神经网络有很多参数因而威力巨大。但是过大的神经网络使得过拟合成为了一个非常严重的问题。Dropout是解决这个问题的一个方法。其主要思想是在训练过程中随机舍弃一些单元，而验证这种方法效果的方式也很简单：通过和不经过Dropout，而大小与经过Dropout的模型相近的神经网络模型进行对比。通过实验，这种方法能够很好地防止过拟合，并且和目前的一些正则化方法相比有了明显的提升。 Introduction深度神经网络包含了许多非线性隐藏层，这使得深度神经网络变得有很强的表达性，也就是说其可以学习输入和输出之间的复杂的关系。 但是当训练数据有限的时候，可能部分关系是从采样噪声学到的，这些关系在训练集中存在但在实际的测试数据中不存在。这就导致了过拟合。 减少过拟合的方法包括，验证集上的性能开始下降时尽快停止训练，为权重引入L1/L2正则惩罚项。 如果计算量上不受限制，按照bayesian的黄金准则，regularize 一个固定规模的模型的最好的方式是，在参数的所有可能的取值上做预测，再根据每种取值的后验概率对这些预测加权取平均。实际中希望用更少的计算量近似到达bayesian的性能。 本文提出dropout，学习指数个共享参数的模型，做预测，求几何平均。近似地有效地组合了指数多个神经网络体系结构。 Dropout做法，暂时地随机地移除网络中的单元（及其输入和输出连接）。比如，每个单元都以固定的概率$p$（比如=0.5）保留。（但是输入单元的保留概率应该接近1），相当于从原网络中采样一个thinned稀疏的网络。 原网络有$n$个单元，则有$2^n$种可能（每个节点有移除/保留2种可能,各节点独立）的稀疏网络。 在测试的时候，直接地先对每个网络做预测再平均 计算量大不可行。采用近似平均方法，将$2^n$个网络组合成一个神经网络（所有单元都保留，但单元的输出权重都乘以该单元在训练时候的保留概率），基于这个神经网络做预测。 MotivationDropout的动机来自于关于性别在进化中的作用的理论。有性生殖包括从一个亲本和另一个亲本中提取一半的基因，加入非常少量的随机突变，并将它们结合产生受精卵。无性繁殖是通过父母基因的拷贝中加入微小突变来创造后代。无性繁殖应该是一种更好的方法来优化个体的健康，这似乎是合理的，因为一组良好的基因组合在一起可以直接传递给后代。另一方面，有性生殖很可能会破坏这些共同适应的基因，特别是如果这些基因的数量很大，而且直觉上，这应该会降低已经进化出复杂的共同适应的生物体的适应性。然而，有性繁殖是最先进的生物进化的方式。 对有性生殖优势的一种可能解释是，从长期来看，自然选择的标准可能不是个体特性，而是基因的混合能力。就是说那些能够和更多随机的基因协作的基因才是更加健壮的。因此一些基因必须要自己学会做一些事而不只是跟很多其他基因合作，这种合作会减少个体适应性。类似地，随机的选择dropout可以增加隐层神经元的健壮性。 有个密切相关但却略有不同的例子，十个阴谋，每个五人参与和一个大阴谋五十人参与相比，显然前者获得一次成功概率较大。一个复杂的共同协作的网络在训练集表现会很出色，但到测试集中，出现了很多新的数据，他就不如很多个更为简单的协作神经元工作的效果好。 Model Description考虑一个有着$L$层隐藏层的神经网络，让$l \in {1,….,L }$ 表示隐藏层的层数，让$z^{(l)}$ 表示输入到第$l$c层神经网络的向量，$y^{(l)}$ 表示第$l$层神经网络的输出，$W^{(l)}$表示第$l$层神经网络的权重，$b^{(l)}$表示第$l$层神经网络的bias$$\begin{aligned} z _ { i } ^ { ( l + 1 ) } &amp; = \mathbf { w } _ { i } ^ { ( l + 1 ) } \mathbf { y } ^ { l } + b _ { i } ^ { ( l + 1 ) } \ y _ { i } ^ { ( l + 1 ) } &amp; = f \left( z _ { i } ^ { ( l + 1 ) } \right) \end{aligned}$$ 左图：普通神经网络。右图：dropout之后的神经网络 $$\begin{aligned} r _ { j } ^ { ( l ) } &amp; \sim \text { Bernoulli } ( p ) \ \widetilde { \mathbf { y } } ^ { ( l ) } &amp; = \mathbf { r } ^ { ( l ) } * \mathbf { y } ^ { ( l ) } , \ z _ { i } ^ { ( l + 1 ) } &amp; = \mathbf { w } _ { i } ^ { ( l + 1 ) } \widetilde { \mathbf { y } } ^ { l } + b _ { i } ^ { ( l + 1 ) } \ y _ { i } ^ { ( l + 1 ) } &amp; = f \left( z _ { i } ^ { ( l + 1 ) } \right) \end{aligned}$$ ConclusionDropout是一种可以在神经网络中减小过拟合程度的一种方法。普通的反向传播算法只能在学习到训练集中的知识但是泛化性能不够。而随机的Dropout使得每一个隐藏层的单元都不一定会在输出中起到作用，因此能够提升神经网络在各个领域内的使用性能。 Dropout的一个缺点是它使得训练的时间延长了，通常来说，一个使用Dropout来训练的神经网络会比拥有相同结构的普通神经网络耗费2-3倍的时间，这主要是因为变量的更新较为缓慢，每一次更新都是几乎不相同的结构。当然有得必有失，在机器学习的领域中，要想获得一方面的进步，就要在其他方面做出让步。Dropout方法增加了算法的训练时间，降低了模型的过拟合风险。]]></content>
      <categories>
        <category>CS</category>
        <category>paper</category>
      </categories>
      <tags>
        <tag>paper</tag>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robotics-Linear Control]]></title>
    <url>%2F2018%2F12%2F27%2FRobotics-Linear%20Control%2F</url>
    <content type="text"><![CDATA[1 IntroductionPremise: Know the means to calculate joint-position correspond to desired end-effector motions. Problem: Howto casuse the manipulator acually to perform these desired motions. Solution 1: Linear control system. In fact, non-linear is more usual, linear control is just a approximate methods It’s resonable to make such approximation, so lineat control methods are the ones most often used in industrial practice. Learn linear first is good for later study 2 Control-Law PartitioningPartitioning Method (2 parts): model-based portion: make use of supposed knowledge of m,b,k, to make the system appear as a unit mass$\to$ servo portion simple. servo portion: make use of feedback to modify the behavior of the system A open-loop equation of motion for the system:$$m \ddot { x } + b \dot { x } + k x = f$$The model-based portion of the control:$$f = \alpha f ^ { \prime } + \beta$$and we choose(because we want to make the )$$\begin{array} { l } { \alpha = m } \ { \beta = b \dot { x } + k x } \end{array}$$finally we get $\ddot { x } = f ^ { \prime }$ Graphiclly,we transform a system like this into a system easier What we need to do is design a control law to compute $f ^ { \prime } = - k _ { v } \dot { x } - k _ { p } x$ so it yields$$\ddot { x } + k _ { v } \dot { x } + k _ { p } x = 0$$ Conclusion get the system‘s parameters find $\alpha ,\beta$ calculate $k_v,k_p$ depend on the requirement 3. Trajectory-Following ControlKnow: trajectory, a funciton of time $x_d(t)$ and we can get $\dot x_d, \ddot x_d $as well Define: $e=x_d-x$ Design $f ^ { \prime } = \ddot { x } _ { d } + k _ { v } \dot { e } + k _ { p } e$ Get: $\ddot { x } = \ddot { x } _ { d } + k _ { v } \dot { e } + k _ { p } e$ So, we can choose coefficients and design any response we want]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>control</tag>
        <tag>robotics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Evaluate Hypothesis]]></title>
    <url>%2F2018%2F12%2F27%2FEvaluatehypothesis%2F</url>
    <content type="text"><![CDATA[Motivationhow to evaluate the accuracy of the algorithm Key Problem： test data should not be relative to the hypothesis、]]></content>
      <categories>
        <category>CS</category>
        <category>ML</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32-ADC]]></title>
    <url>%2F2018%2F12%2F27%2FSTM32-ADC%2F</url>
    <content type="text"><![CDATA[1 IntroductionSTM32 have one of the most advanced ADCs on microcontroller market. This note provide users to understand some modes offered in STM32 2 Independent Mode Single Channel, single conversion Example: Check if the battery voltage is succulent or not Multichannel, single conversion Example: Can be used when starting system depends on some parameters Single Channel, continuous conversion Example: Run in background, so can be used as a monitor to check something all the time Injected conversion Intended for use when conversion is triggered by an external event or by software. 3 Example Code1234567891011121314151617181920212223242526272829303132333435363738394041void GPIOINIT_ADC()&#123; GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;//ADC GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AIN; //模拟输入 GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOB,&amp;GPIO_InitStructure);&#125;void RCCINIT_ADC()&#123; SystemInit(); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE); RCC_ADCCLKConfig(RCC_PCLK2_Div6);//12M 最大14M 设置ADC时钟（ADCCLK）&#125;void ADCINIT_ADC()&#123; ADC_InitTypeDef ADC_InitStructure; ADC_InitStructure.ADC_Mode = ADC_Mode_Independent; ADC_InitStructure.ADC_ScanConvMode = DISABLE; ADC_InitStructure.ADC_ContinuousConvMode = DISABLE; ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right; ADC_InitStructure.ADC_NbrOfChannel = 1; ADC_Init(ADC1, &amp;ADC_InitStructure); ADC_TempSensorVrefintCmd(ENABLE); ADC_Cmd(ADC1,ENABLE); ADC_ResetCalibration(ADC1);//重置指定的ADC的校准寄存器 while(ADC_GetResetCalibrationStatus(ADC1));//获取ADC重置校准寄存器的状态 ADC_StartCalibration(ADC1);//开始指定ADC的校准状态 while(ADC_GetCalibrationStatus(ADC1));//获取指定ADC的校准程序 ADC_RegularChannelConfig(ADC1,ADC_Channel_8,1,ADC_SampleTime_239Cycles5);//设置指定ADC的规则组通道，设置它们的转化顺序和采样时间 ADC_SoftwareStartConvCmd(ADC1, ENABLE);//使能或者失能指定的ADC的软件转换启动功能 while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);&#125;]]></content>
      <categories>
        <category>Embedded System</category>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>ADC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Robotics-Trajectory]]></title>
    <url>%2F2018%2F12%2F25%2FRobotics-Trajectory%2F</url>
    <content type="text"><![CDATA[1 Introduction trajectory refers to a time history of position, velocity, and acceleration for each degree of freedom. Concern: Easy description：just desired goal position and orientation How to generating and representing in computer 2 General consideration Huamn-interface. Consider tool frame ${T}$ , in which a user would think and design path. Path include many intermediate points (position and orientation) Want a smooth path, first derivative even second derivative. jerky motions tend to cause increased wear on the mechanism andcause vibrations by exciting resonances in the manipulator 3 Joint-Space SchemesFirst get the via points and then convert it to a set of joint angle by inverse kinematics Joint space schemes is the easiest to compute. 3.1 Cubic PolynomialsSome constrains: $θ(0) = θ_0$ initial $θ(t_f ) = θ_f$ final $\dotθ(0) = 0$ continuous in velocity $\dotθ(t_f ) = 0$ continuous in velocity apply$$θ(t) = a_0 + a_1t + a_2t^2 + a_3t^3solve the problem$$to solve the problem (between two points) 3.2 Cubic polynomials for a path with via pointsWhat if we wish to specfify the intermediate via points? (between many points) constrains becoms $θ(0) = θ_0$ initial $θ(t_f ) = θ_f$ final $\dotθ(0) = \dot\theta_0$ continuous in velocity $\dotθ(t_f ) = \dot\theta_f$ continuous in velocity But how we choose the intermediate velocity? There are some method: Specified by user Choose by computer If the slope of lines change sign at via point $\to$zero velocity if the slope of lines does not change sign$\to$average velocity 3.3 Linear function with parabolic blends $$\ddotθ\times t_b =\frac{θ_h − θ_b}{t_h − t_b}$$ $$θ_b = θ_0 + \frac12\ddotθ\times t_b^2$$ There are 2 equations and 6 variabels So, given $\theta_f ,\theta_0, t_h$, choose $\ddot\theta\to$we can calculate $t_b$ 3.4 Linear function with parabolic blends for a path with via pointsConsider there an arbitrary number of via points 4 Cartesian-Space Schemes In Joint-Space, the spatial shape of path taken by the end-effector will be complicated In Cartesian-Space, we can also specify shape of the path. Line\Circular\Sinusoidal However, Cartesian schemes are more computationally expensive because inverse kinematics must be solved at real time 5 Geometric Problems with Cartesian Paths Intermediate points unreachable High joint rates near singularity Start and goal reachable in different solutions]]></content>
      <categories>
        <category>Robotics</category>
        <category>Introduction to Robotics Notes</category>
      </categories>
      <tags>
        <tag>robotics</tag>
        <tag>trajectory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADS-Analysis]]></title>
    <url>%2F2018%2F12%2F24%2FADS-Analysis%2F</url>
    <content type="text"><![CDATA[1. Big Picture What makes a program better？many valid criteria, which are often in conflict. omputer scientists love Time Memory trade off sum of 1-n： simple add gauss formula 2. Big O Notation f(n) Name 1 Constant $log n$ Logarithmic $n$ Linear $nlogn$ Log Linear $n^2$ Quadratic $n^3$ Cubic $2^n$ Exponential 3. Example :Anagram Detection Checking off: check one by one ,$O(n^2)$. Sort and Compare: $O(nlogn)$ Brute Force , try all possibilities: $O(n!)$ Count and Compare: $O(n)$ 4. Performance of Python Types Lists Indexing &amp; Assigning &amp; Appending $O(1)$ Poping, Shifting &amp; Deleting, normally $O(n)$ ,beacuse has to shift changed element Reversing $O(n)$ Dictionaries “getting” and “setting” : $O(1)$ Iterating &amp; Copying: $O(n)$]]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADS-Stacks]]></title>
    <url>%2F2018%2F12%2F24%2FADS-Stacks%2F</url>
    <content type="text"><![CDATA[1. Introduction to StacksStacks is a kind of linear data structures. What distinguishes one linear structure from another is where additions and removals may occur 1.1 Stacks A stack is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end. Example: stack of books\plates, URL back button Usage: reverse the order 1.2 ADT ADT data represents DS physical implementation of an ADT Stack operation Stack contents Return value s.is_empty() [] True s.push(4) [4] s.push(‘dog’) [4, ‘dog’] s.peek() [4, ‘dog’] ‘dog’ s.push(True) [4, ‘dog’, True] s.size() [4, ‘dog’, True] 3 s.is_empty() [4, ‘dog’, True] False s.push(8.4) [4, ‘dog’, True, 8.4] s.pop() [4, ‘dog’, True] 8.4 s.pop() [4, ‘dog’] True s.size() [4, ‘dog’] 2 2. A Stack ImplementationIn practice , “use a Python list as a stack” even though the implementations are logically equivalent, they would have very different timings when performing benchmark testing. Here, just use python list with limit function. 3. Example:Balanced Parenthesesparentheses are used to order the performance of operations $$(5+6)×(7+8)/(4+3)$$ or lisp function 12(defun square(n) (* n n)) So,it’s important to differentiate between parentheses that are correctly balanced and those that are unbalanced in strucures. Why Stack ? open match close\ close match open, reverse order So a stack, push if open, pop if close. Finally, if len(stack)==0, balance. 123456789101112131415161718192021222324252627PAIRINGS = &#123; '(': ')', '&#123;': '&#125;', '[': ']'&#125;def is_balanced(symbols): stack = [] for s in symbols: if s in PAIRINGS.keys(): stack.append(s) continue try: expected_opening_symbol = stack.pop() except IndexError: # too many closing symbols return False if s != PAIRINGS[expected_opening_symbol]: # mismatch return False return len(stack) == 0 # false if too many opening symbolsis_balanced('&#123;&#123;([][])&#125;()&#125;') # =&gt; Trueis_balanced('&#123;[])') # =&gt; Falseis_balanced('((()))') # =&gt; Trueis_balanced('(()') # =&gt; Falseis_balanced('())') # =&gt; False 4. Example: Converting Number Bases$$233_{10}=11101001_{2}$$ Why stack？ Divide by Base algorithm So, Push fisrt, Pop at the end 1234567891011121314151617181920DIGITS = '0123456789abcdef'def convert_to_base(decimal_number, base): remainder_stack = [] while decimal_number &gt; 0: remainder = decimal_number % base remainder_stack.append(remainder) decimal_number = decimal_number // base new_digits = [] while remainder_stack: new_digits.append(DIGITS[remainder_stack.pop()]) return ''.join(new_digits)convert_to_base(25, 2) # =&gt; '11001'convert_to_base(25, 16) # =&gt; '19' 5. Example: Infix, Prefix and Postfix Expressions Infix expression Prefix expression Postfix expression A + B + A B A B + A + B * C + A * B C A B C * + Infix expression need parenthese to force the performance of addition before multiplication. Prefix &amp; Postfixexpression DON’T need it How to convert infix to prefix or postfix? Fully parenthesize the expression using the order of operations. Then move the enclosed operator to the position of either the left or the right parenthesis depending on whether you want prefix or postfix notation. 5.1 Algorithm Create an empty stack called operation_stack for keeping operators. Create an empty list for output. Convert the input infix string to a list by using the string method split. Scan the token list from left to right. If the token is an operand, append it to the end of the output list. If the token is a left parenthesis, push it on the operation_stack. If the token is a right parenthesis, pop the operation_stack until the corresponding left parenthesis is removed. Append each operator to the end of the output list. If the token is an operator, *, /, +, or -, push it on the operation_stack. However, first remove any operators already on the operation_stack that have higher or equal precedence and append them to the output list. When the input expression has been completely processed, check the operation_stack. Any operators still on the stack can be removed and appended to the end of the output list. 5.2 Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445PRECEDENCE = &#123; '*': 3, '/': 3, '+': 2, '-': 2, '(': 1&#125;CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'DIGITS = '0123456789'LEFT_PAREN = '('RIGHT_PAREN = ')'def infix_to_postfix(infix_expression): operation_stack = [] postfix = [] tokens = infix_expression.split() for token in tokens: if token in CHARACTERS or token in DIGITS: postfix.append(token) elif token == LEFT_PAREN: operation_stack.append(token) elif token == RIGHT_PAREN: top_token = operation_stack.pop() while top_token != LEFT_PAREN: postfix.append(top_token) top_token = operation_stack.pop() else: while operation_stack and \ (PRECEDENCE[operation_stack[-1]] &gt;= PRECEDENCE[token]): postfix.append(operation_stack.pop()) operation_stack.append(token) while operation_stack: postfix.append(operation_stack.pop()) return ' '.join(postfix)infix_to_postfix('A * B + C * D') # =&gt; 'A B * C D * +'infix_to_postfix('( A + B ) * C - ( D - E ) * ( F + G )')# =&gt; 'A B + C * D E - F G + * -'infix_to_postfix('( A + B ) * ( C + D )') # =&gt; 'A B + C D + *'infix_to_postfix('( A + B ) * C') # =&gt; 'A B + C *'infix_to_postfix('A + B * C') # =&gt; 'A B C * +']]></content>
      <categories>
        <category>CS</category>
        <category>DS &amp; Algorithm</category>
      </categories>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
