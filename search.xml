<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Robotics-Trajectory]]></title>
    <url>%2F2018%2F12%2F25%2FRobotics-Trajectory%2F</url>
    <content type="text"><![CDATA[1 Introduction trajectory refers to a time history of position, velocity, and acceleration for each degree of freedom. Concern: Easy description：just desired goal position and orientation How to generating and representing in computer 2 General consideration Huamn-interface. Consider tool frame ${T}$ , in which a user would think and design path. Path include many intermediate points (position and orientation) Want a smooth path, first derivative even second derivative. jerky motions tend to cause increased wear on the mechanism andcause vibrations by exciting resonances in the manipulator 3 Joint-Space SchemesFirst get the via points and then convert it to a set of joint angle by inverse kinematics Joint space schemes is the easiest to compute. 3.1 Cubic PolynomialsSome constrains: $θ(0) = θ_0$ initial $θ(t_f ) = θ_f$ final $\dotθ(0) = 0$ continuous in velocity $\dotθ(t_f ) = 0$ continuous in velocity apply$$θ(t) = a_0 + a_1t + a_2t^2 + a_3t^3solve the problem$$to solve the problem (between two points) 3.2 Cubic polynomials for a path with via pointsWhat if we wish to specfify the intermediate via points? (between many points) constrains becoms $θ(0) = θ_0$ initial $θ(t_f ) = θ_f$ final $\dotθ(0) = \dot\theta_0$ continuous in velocity $\dotθ(t_f ) = \dot\theta_f$ continuous in velocity But how we choose the intermediate velocity? There are some method: Specified by user Choose by computer If the slope of lines change sign at via point $\to$zero velocity if the slope of lines does not change sign$\to$average velocity 3.3 Linear function with parabolic blends $$\ddotθ\times t_b =\frac{θ_h − θ_b}{t_h − t_b}$$ $$θ_b = θ_0 + \frac12\ddotθ\times t_b^2$$ There are 2 equations and 6 variabels So, given $\theta_f ,\theta_0, t_h$, choose $\ddot\theta\to$we can calculate $t_b$ 3.4 Linear function with parabolic blends for a path with via pointsConsider there an arbitrary number of via points 4 Cartesian-Space Schemes In Joint-Space, the spatial shape of path taken by the end-effector will be complicated In Cartesian-Space, we can also specify shape of the path. Line\Circular\Sinusoidal However, Cartesian schemes are more computationally expensive because inverse kinematics must be solved at real time 5 Geometric Problems with Cartesian Paths Intermediate points unreachable High joint rates near singularity Start and goal reachable in different solutions]]></content>
      <categories>
        <category>Robotics</category>
      </categories>
      <tags>
        <tag>trajectory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PADS-Analysis]]></title>
    <url>%2F2018%2F12%2F24%2FADS-Analysis%2F</url>
    <content type="text"><![CDATA[1. Big Picture What makes a program better？many valid criteria, which are often in conflict. omputer scientists love Time Memory trade off sum of 1-n： simple add gauss formula 2. Big O Notation f(n) Name 1 Constant $log n$ Logarithmic $n$ Linear $nlogn$ Log Linear $n^2$ Quadratic $n^3$ Cubic $2^n$ Exponential 3. Example :Anagram Detection Checking off: check one by one ,$O(n^2)$. Sort and Compare: $O(nlogn)$ Brute Force , try all possibilities: $O(n!)$ Count and Compare: $O(n)$ 4. Performance of Python Types Lists Indexing &amp; Assigning &amp; Appending $O(1)$ Poping, Shifting &amp; Deleting, normally $O(n)$ ,beacuse has to shift changed element Reversing $O(n)$ Dictionaries “getting” and “setting” : $O(1)$ Iterating &amp; Copying: $O(n)$]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PADS-Stacks]]></title>
    <url>%2F2018%2F12%2F24%2FADS-Stacks%2F</url>
    <content type="text"><![CDATA[1. Introduction to StacksStacks is a kind of linear data structures. What distinguishes one linear structure from another is where additions and removals may occur 1.1 Stacks A stack is an ordered collection of items where the addition of new items and the removal of existing items always takes place at the same end. Example: stack of books\plates, URL back button Usage: reverse the order 1.2 ADT ADT data represents DS physical implementation of an ADT Stack operation Stack contents Return value s.is_empty() [] True s.push(4) [4] s.push(‘dog’) [4, ‘dog’] s.peek() [4, ‘dog’] ‘dog’ s.push(True) [4, ‘dog’, True] s.size() [4, ‘dog’, True] 3 s.is_empty() [4, ‘dog’, True] False s.push(8.4) [4, ‘dog’, True, 8.4] s.pop() [4, ‘dog’, True] 8.4 s.pop() [4, ‘dog’] True s.size() [4, ‘dog’] 2 2. A Stack ImplementationIn practice , “use a Python list as a stack” even though the implementations are logically equivalent, they would have very different timings when performing benchmark testing. Here, just use python list with limit function. 3. Example:Balanced Parenthesesparentheses are used to order the performance of operations $$(5+6)×(7+8)/(4+3)$$ or lisp function 12(defun square(n) (* n n)) So,it’s important to differentiate between parentheses that are correctly balanced and those that are unbalanced in strucures. Why Stack ? open match close\ close match open, reverse order So a stack, push if open, pop if close. Finally, if len(stack)==0, balance. 123456789101112131415161718192021222324252627PAIRINGS = &#123; '(': ')', '&#123;': '&#125;', '[': ']'&#125;def is_balanced(symbols): stack = [] for s in symbols: if s in PAIRINGS.keys(): stack.append(s) continue try: expected_opening_symbol = stack.pop() except IndexError: # too many closing symbols return False if s != PAIRINGS[expected_opening_symbol]: # mismatch return False return len(stack) == 0 # false if too many opening symbolsis_balanced('&#123;&#123;([][])&#125;()&#125;') # =&gt; Trueis_balanced('&#123;[])') # =&gt; Falseis_balanced('((()))') # =&gt; Trueis_balanced('(()') # =&gt; Falseis_balanced('())') # =&gt; False 4. Example: Converting Number Bases$$233_{10}=11101001_{2}$$ Why stack？ Divide by Base algorithm So, Push fisrt, Pop at the end 1234567891011121314151617181920DIGITS = '0123456789abcdef'def convert_to_base(decimal_number, base): remainder_stack = [] while decimal_number &gt; 0: remainder = decimal_number % base remainder_stack.append(remainder) decimal_number = decimal_number // base new_digits = [] while remainder_stack: new_digits.append(DIGITS[remainder_stack.pop()]) return ''.join(new_digits)convert_to_base(25, 2) # =&gt; '11001'convert_to_base(25, 16) # =&gt; '19' 5. Example: Infix, Prefix and Postfix Expressions Infix expression Prefix expression Postfix expression A + B + A B A B + A + B * C + A * B C A B C * + Infix expression need parenthese to force the performance of addition before multiplication. Prefix &amp; Postfixexpression DON’T need it How to convert infix to prefix or postfix? Fully parenthesize the expression using the order of operations. Then move the enclosed operator to the position of either the left or the right parenthesis depending on whether you want prefix or postfix notation. 5.1 Algorithm Create an empty stack called operation_stack for keeping operators. Create an empty list for output. Convert the input infix string to a list by using the string method split. Scan the token list from left to right. If the token is an operand, append it to the end of the output list. If the token is a left parenthesis, push it on the operation_stack. If the token is a right parenthesis, pop the operation_stack until the corresponding left parenthesis is removed. Append each operator to the end of the output list. If the token is an operator, *, /, +, or -, push it on the operation_stack. However, first remove any operators already on the operation_stack that have higher or equal precedence and append them to the output list. When the input expression has been completely processed, check the operation_stack. Any operators still on the stack can be removed and appended to the end of the output list. 5.2 Implementation123456789101112131415161718192021222324252627282930313233343536373839404142434445PRECEDENCE = &#123; '*': 3, '/': 3, '+': 2, '-': 2, '(': 1&#125;CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'DIGITS = '0123456789'LEFT_PAREN = '('RIGHT_PAREN = ')'def infix_to_postfix(infix_expression): operation_stack = [] postfix = [] tokens = infix_expression.split() for token in tokens: if token in CHARACTERS or token in DIGITS: postfix.append(token) elif token == LEFT_PAREN: operation_stack.append(token) elif token == RIGHT_PAREN: top_token = operation_stack.pop() while top_token != LEFT_PAREN: postfix.append(top_token) top_token = operation_stack.pop() else: while operation_stack and \ (PRECEDENCE[operation_stack[-1]] &gt;= PRECEDENCE[token]): postfix.append(operation_stack.pop()) operation_stack.append(token) while operation_stack: postfix.append(operation_stack.pop()) return ' '.join(postfix)infix_to_postfix('A * B + C * D') # =&gt; 'A B * C D * +'infix_to_postfix('( A + B ) * C - ( D - E ) * ( F + G )')# =&gt; 'A B + C * D E - F G + * -'infix_to_postfix('( A + B ) * ( C + D )') # =&gt; 'A B + C D + *'infix_to_postfix('( A + B ) * C') # =&gt; 'A B + C *'infix_to_postfix('A + B * C') # =&gt; 'A B C * +']]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
